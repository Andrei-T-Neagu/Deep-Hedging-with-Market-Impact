import datetime as dt
import math
import numpy as np
import torch
import torch.nn as nn 
import torch.nn.functional as F
import matplotlib.pyplot as plt
import Utils_general
import DeepAgent as DeepAgent
import DeepAgentTransformer
import DeepAgentLSTM as DeepAgentLSTM
import DeepAgentGRU as DeepAgentGRU
from scipy.stats import ttest_ind

nbs_point_traj = 13
batch_size = 256
train_size = 100000
test_size = 100000
epochs = 100
r_borrow = 0
r_lend = 0
stock_dyn = "BSM" 
params_vect = [0.1, 0.1898]
S_0 = 1000
T = 252/252
alpha = 1.01
beta = 0.99
loss_type = "RSMSE"
option_type = "call"
position_type = "short"
strike = 1000
nbs_layers = 4
nbs_units = 256
lr = 0.0001
prepro_stock = "log-moneyness"
nbs_shares = 1
lambdas = [-1, -1]

if (option_type == 'Call'):
    V_0 = Utils_general.BlackScholes_price(S_0, T, r_borrow, params_vect[1], strike, 1)
else:
    V_0 = Utils_general.BlackScholes_price(S_0, T, r_borrow, params_vect[1], strike, -1)

# Creating test dataset
mu, sigma = params_vect
N = nbs_point_traj - 1
dt = T / N
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
test_set = S_0 * torch.ones(int(test_size/batch_size), nbs_point_traj, batch_size, device=device)
for i in range(int(test_size/batch_size)):
    S_t = S_0 * torch.ones(batch_size, device=device)
    for j in range(N):
        Z = torch.randn(batch_size, device=device)
        S_t = S_t * torch.exp((mu - sigma ** 2 / 2) * dt + sigma * math.sqrt(dt) * Z)
        test_set[i, j+1, :] = S_t

strikes = [800, 1000, 1200]
loss_types = ["RSMSE"]
impact_values = [0.01, 0.025]
impact_persistence = [0, -math.log(0.5)/dt, -math.log(0.3333)/dt, -1] # impact persistence of {1, 0.5, 0.33, 0}
for loss in loss_types:
    for strike in strikes:
        for impact in impact_values:
            loss_type = loss
            alpha = 1.0+impact
            beta = 1.0-impact

            fig = plt.figure(figsize=(10, 5))

            for persistence in impact_persistence:
                lambdas = [persistence, persistence]
                name = "code_pytorch/impact_persistence/{loss_type}_hedging_{strike:d}_strike_{impact:.4f}_market_impact_{persistence:.4f}_persistence".format(loss_type=loss, impact=impact, strike=strike, persistence=persistence)
                agent = DeepAgent.DeepAgent(nbs_point_traj, batch_size, r_borrow, r_lend, stock_dyn, params_vect, S_0, T, alpha, beta,
                                loss_type, option_type, position_type, strike, V_0, nbs_layers, nbs_units, lr, prepro_stock,
                                nbs_shares, lambdas, name=name)

                print("START FFNN {loss_type} - {strike:d} STRIKE - {impact:.4f} IMPACT - {persistence:.4f} IMPACT PERSISTENCE".format(loss_type=loss_type, strike=strike, impact=impact, persistence=persistence))
                all_losses, epoch_losses = agent.train(train_size = train_size, epochs=epochs)

                print("DONE FFNN {loss_type} - {strike:d} STRIKE - {impact:.4f} IMPACT - {persistence:.4f} IMPACT PERSISTENCE".format(loss_type=loss_type, strike=strike, impact=impact, persistence=persistence))
                agent.model = torch.load("/home/a_eagu/Deep-Hedging-with-Market-Impact/" + name)
                deltas, hedging_err, S_t, V_t, A_t, B_t, = agent.test(test_size=test_size, test_set=test_set)
                semi_square_hedging_err = np.square(np.where(hedging_err > 0, hedging_err, 0))
                rsmse = np.sqrt(np.mean(semi_square_hedging_err))

                print(" ----------------- ")
                print(" Deep Hedging {loss_type} - {strike:d} STRIKE - {impact:.4f} IMPACT - {persistence:.4f} IMPACT PERSISTENCE - RESULTS".format(loss_type=loss_type, strike=strike, impact=impact, persistence=persistence))
                print(" ----------------- ")
                Utils_general.print_stats(hedging_err, deltas, loss_type, "Deep hedge - FFNN - %s" % (loss_type), V_0)

                def count_parameters(agent):
                    return sum(p.numel() for p in agent.model.parameters() if p.requires_grad)

                print("FFNN PARAMETERS: ", count_parameters(agent))

                # Single point prediction
                spot_prices = np.linspace(700, 1300, num=25).tolist()
                spot_prices_dh = np.tile(spot_prices, (nbs_point_traj, 1))
                deltas_DH, hedging_err_DH = Utils_general.delta_hedge_res(spot_prices_dh, r_borrow, r_lend, params_vect[1], T, alpha, beta, option_type="Call", position_type="Short", strike=strike, V_0=V_0, nbs_shares=nbs_shares, hab=lambdas)
                deltas = np.zeros((25))
                for i, spot in enumerate(spot_prices):
                    point_pred = agent.point_predict(t=6, S_t=spot, V_t=V_0, A_t=0.5, B_t=0.5, delta_t=0.5)
                    deltas[i] = point_pred

                
                plt.plot(deltas, label="Global Hedge with lambdas = {:.4f}".format(persistence))
                
                print()
            
            plt.plot(deltas_DH[0], label="Delta hedge")
            prices = list(range(700, 1400, 100))
            indices = list(range(0, len(spot_prices), 4))
            plt.xlabel('Spot price')
            plt.xticks(indices, prices)
            plt.ylabel('Share of stock (delta_{t+1})')
            plt.grid()
            plt.legend()
            plt.title("ATM Call - Delta Hedge vs {loss_type} - {strike:d} Strike - {impact:.4f} Market Impact - {persistence:.4f} Persistence - time_t = 0.5000".format(loss_type=loss, impact=impact, strike=strike, persistence=persistence))
            plt.savefig("code_pytorch/impact_persistence/{loss_type}_hedging_{strike:d}_strike_{impact:.4f}_market_impact_{persistence:.4f}_persistence.jpg".format(loss_type=loss, impact=impact, strike=strike, persistence=persistence))